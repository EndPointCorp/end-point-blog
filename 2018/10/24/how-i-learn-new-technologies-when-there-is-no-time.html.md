---
author: "Arpad"
title: "How I learn new technologies when there is no time"
tags: tips, learning
---

If a developer has plenty of time, then the best way to learn a technology is to read a book about it and solve the tasks the book presents, then to do some very basic tasks just to get some real world experience. When this is done, one might want to watch some tutorial videos, consult with people, who are also learning or, even better, if they are experienced in the given technology. When someone gets comfortable with a dev stack, the person might be inclined to prefer to work only in his or her comfort zone. This is more often than not feasible. But what if someone gets a new project in a different dev stack? Is it a great problem? In my opinion, it's not a problem, *if we are able to determine the minimal knowledge we need to get started*. In the real world a client will not really want to wait and pay for a developer to read a book. So how can a developer quickly grasp the essence of the problem space, from where the most frequent questions are reachable?

To answer the question I explain how I developed my learning method. The first time I've seen a PC was in 1993 and I used it to play some games for years. I had no clue about DOS and I did not speak English, so it was an x,y problem. The knowledge I needed back then in order to play games was limited to:

- what a hard drive is
- what a folder or a file is
- what a file is
- how to execute a file
- how to copy a file
- how to switch hard drives

For me the meaning of the words I typed to reach my goal were misterious, but I was very motivated to achieve my goal and play. As a child I did not want to learn how to speak English on a beginner level and I was not interested in reading technical manuals. The commands were shown by a friend and I was ready to go and play. In this example I fulfilled two roles: I was the end client, as I was the person who benefited from my effort and I was the service provider as well. I had no internet, I did not speak English, I was not a technical expert whatsoever, but I really wanted to play.

While playing the games, even complex strategic games I had some difficulties, as I did not speak English, but I wanted to win, so, from the context I had from the game I grasped the meaning of some English words, just enough in order to be able to play the game well.

As a child who wanted to play and win, I unkowingly used a very plausible method to learn new things, because the alternative was to go outside and play with other kids. While it would have been surely healthier to go outside, as a child I did not think much about health and was more interested to play.

Fast forward, when I was a highschool student and I had the joy to actually have the opportunity to study informatics, they actually did not let us enter into a computer lab and write small programs. They were only teaching us alrogithms, which was very simple and boring for me, so I studied to program in Pascal at home. Actually a neighbor teached me weekly, but I always learned the lesson before our meeting to minimalize the learning time and focus on our chess. So, usually we spent half an hour while I explained him what I learned and while he corrected me whenever I was wrong, so we had a great time and we were always finishing the lesson part very quickly. While learning Pascal I used the orthodox method of reading a book and solving the tasks it gives me and it took me half a year, however, my main focus during this time was something else than programming. At highschool they teached us for three years Pascal and the lessons quickly became boring. I was more interested in writing larger projects.

However, as a student at the university I was learning the way they teached us, I listened to the professor's explanation, written the small programs they asked for and this way I learned C in a year. I noticed that grasping C was longer for me than grasping Pascal, but I attributed this to the syntax of C, which was less intuitive for me back then in comparison with Pascal. I observed this fact, but did not give much importance to it.

In 2008 I graduated from the university and was looking for a job, but in the middle of the world economic crisis fresh programmers did not have much chance to get a job. Due to these difficulties I had to accept very small projects from various clients, which were using different technologies. To be able to do this I had to revise my method of learning technologies. I particularly remember the case when in 2009 I had a small Javascript project and I had no knowledge whatsoever and a deadline of 24 hours, as the client needed the job done ASAP. Reading a book was not an option. Even a tutorial was too long, so after four hours of trying hard to solve the problem I watched Douglas Crockford's <a href="https://www.youtube.com/watch?v=v2ifWcnQs6M">video</a>. After so much suffering, his joke "Good morning, everybody, welcome to the Blair Witch project" was more than fitting about how I felt in that situation. After four hours of suffering I finally found an ally. With the help of this video I was able to grasp the **core** of the knowledge I needed, that is, the information I need to be able to quickly find other information if needed. After watching the video, I completed the small project without much difficulty. Of course, it was a new language for me, but at least I had some understanding. That case teached me the importance of quickly grasping the core of the new technology I am about to learn.

The methodology is to put the appropriate questions needed to be answered into a list. By looking at the answer of each question, I can acquire the core knowledge which allows me to work with the given technology. Of course, working with a technology one has no previous experience with takes more time in comparison with working with a technology one has years of experience with, because even the most trivial tasks might need some research, but if the core knowledge is already acquired, then 90% of the answers to the question one may have while working are easily answered.

### New Programming Language

1. What justifies the existence of the language, what is the purpose the language aims to fulfill?
2. Where can I find the original documentation and how do I search and navigate there?
3. Is the syntax similar to a language I already know? How are commands separated, what are the keywords one will frequently use?
4. What type of things will I work with using the language? With CSS I am to define rules which are specifying the looks of a web-page. With query languages I am to work with databases, relations/tables, records and columns. With HTML or XML I am to define a node hierarchy. With C I am going to write functions. With Java I am going to define classes and objects.
5. What types of tasks can I expect from the projects I can work with?
6. Can I watch a tutorial video? Watching an introductory video takes hours. Reading a book takes week(s).
7. What operating system should I use?
8. What IDE should I use?
9. Is there an online possibility to write experimental code to try my hand in this new language?
10. Do I need to register to community forums?
11. Do I have questions I do not have the answer yet? If so, since I am new to the language, my questions are probably very simple, as I am on a level everyone "speaking" the language has been, so I should not have difficulty in finding an answer for my question at community forums or general purpose programming Q&A sites.
12. Have I written a sample Hello World in the language?
13. What will I have to watch for?
14. What are the best practices for coding in the given language?

### New Operating System

1. Do I have access to a computer from where I can search the internet while I am total noob with the other operating system?
2. How to operate with files and folders?
3. How to install/run an application?
4. What is the minimal knowledge I need in order to be able to work on my programming tasks?

### New Libraries and Tools

1. Why do I need this?
2. Which are the features and use-cases I will be using?
3. What are the names of functions/methods I will be working with frequently?
4. What do I need to do to use this?
5. Is it documented, does it have a forum?

### New Projects

1. What is the aim of the project?
2. What are the technologies in use which I have experience with?
3. What are the technologies in use which I do not have experience with? Is it urgent to learn them?
4. What are the main features of the project?
5. What will I have to interact with first in the project?
6. Can I play around with the project and do some experiments without being in danger of doing any harm to it?
7. Is it documented?
8. How am I going to work with it, what do I need to download/install, what networks am I going to access?
9. How is the personality of the client affecting the working relationship? Am I going to have an easy time or not in my first days?
10. Where are the vital points of the project and can I take a look at the code there to have a vague understanding of what is being done?

### New Concepts

1. What is the definition of the concept?
2. Is it related to something I already know?
3. Does it have subconcepts?
4. Do I need to understand something complex? If so, can I find/draw some illustrative diagrams?
5. Can I make a fairly accurate allegory, using elements I am aware of? 

### Allegory

In general, if something is not understandable at all for me, or has so many elements that it will be difficult to remember them all, I construct an allegory, using concepts I am already aware of. This way, if I forget anything from my newly acquired knowledge, then I think about my allegory, which serves as a mental decryption method.

For instance, when I learned about object oriented concepts, I used the allegory of set theory to understand the concepts. I viewed classes as active sets, that is, sets which might have executable methods. I viewed objects as items in a set, which, on their own have their capability to perform actions. I viewed inheritance as a subset relation. To make the allegory more-or-less full, I had trouble in integrating abstract classes and interfaces into the allegory, but after thinking about them a while, I came up with a solution. I considered abstract classes as partial definitions of a set and interfaces as declarations of the sets. Since neither had a complete definition, we need a nonabstract subset to find items to these sets. Method overloading was easily understood for me as doing something using different domains. a * b is different if both a and b are real numbers and different if they are complex, basically we do the same operations, but with different variables. I added method overriding into my allegory as an evolution of methods, or as a specialization. While the allegory was not exactly 100% analogous with the concepts I needed to understand, with this allegory constructed while reading the concepts I was confident that even if I do not remember all the details in a future situation, I will be able to decrypt most of it using the allegory. In many cases this is ennough by itself, but when it's not enough, the allegory helped me to formulate intelligent questions, which I could transform to keywords which are searchable by a search engine.

### Notes

I am sure I am not the only human being with bad sectors in his or her brain. Did you ever had the experience of totally understanding something and then always forgetting an important detail, but only that detail? Well, we are not at a class room where we need to speak accurately all the verses of a long poem. We can write notes. If I observe that I am regularly forgetting something which is important, then I am making notes.

### Closing Words

The methods I described in this article are working well for me. We are different, what works for me does not necessarily work for you and vice-versa. However, I think that this approach can be personalized. If you feel that you need to do things differently in comparison to what I described here, then you are probably right, as you have a different brain and it probably does not work in the exact same way as mine. For me, when I learn, frequent short breaks are helpful, as my subconscious is working out without any effort some details which are more difficult for my conscious thinking. After I read an article, if I take a walk and breath fresh air, I tend to have deeper knowledge when I return than when I started to walk.

We also have different mental skills. Some people are very good at processing data and reaching conclusions, others are better at memorizing things. One needs to adjust his or her learning process to his or her mental powers. If you remember things better if you speak them loudly, you might need to do so. If you remember pictures, then drawing diagrams are better. Whenever we are stuck with something, a role playing might help, if we are the teacher and the student at the same time. While I explain myself something I do not understand and ask the questions, I might find the solution. There were so many times when I explained a problem to someone and in the meantime I realized the solution or, the inverse, someone explained the problem to me and then he or she found out the solution. When you are working from home, you might not have a colleague to explain your problem to within reach, but you can substitute the person with your own self.

It is possible that you need to learn in a totally different way. My words here are not carved into stone. My advice, in general is to not be afraid of new challenges and technologies, it is awesome if you add learning into your comfort zone.
